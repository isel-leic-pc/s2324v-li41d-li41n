= Lecture summaries
:toc: auto

== Week 1

=== Lecture 1: 2023-02-23; 3h

* Course introduction.
** Goals.
** Contents.
** Evaluation.
* Introduction to concurrent programming via a motivating example - a simple TCP/IP echo server.
** The need for multiple flows of execution.
** Creating threads in the JVM.
** Challenges: access to mutable shared data, thread coordination.
* Access to mutable shared data and concurrency hazards.
* Lecture resources.
** link:lecture-notes/0-course-introduction.adoc[Lecture Note].
** link:lecture-notes/1-a-motivating-example.adoc[A motivating example].
** link:lecture-notes/2-threading-data-hazards.adoc[Threading data hazards].
** https://2324moodle.isel.pt/course/view.php?id=7916[Moodle]

== Week 2

=== Lecture 2: 2023-02-26; 1,5h

* Multiple threads of execution.
** Shared and exclusive memory areas.
** Taking advantage of multiple CPUs.
** Using time multiplexing of more than one thread on a single CPU.
** Thread context and context switch.
** Threads states: running, ready, and non-ready.
*** The non-ready state and non-busy waiting.
*** Busy-waiting vs. non-busy waiting.
**** Thread coordination and I/O operations.
* Lecture resources
** link:https://docs.google.com/presentation/d/e/2PACX-1vQq_qqpJRuEQh9iJOlmwgJcumuRpgOxWLpe_Pz9Ecsz565OA2bl9PitjC-EvyISraPNQGQGmFE4Yr7l/pub?start=false&loop=false&delayms=3000&slide=id.p21[Slides].

=== Lecture 3: 2023-03-01; 3h

* link:./exercises/0-intro.adoc[Exercises about basic threading in the JVM and data synchronization hazards].
* Introduction to the `uthreads` library.
** Context switch.
** Scheduling and the ready queue.
** Thread creation and termination.
* link:./exercises/1-uthreads.adoc[Exercises about the `uthreads` library].
* Lecture resources
** link:../native/uthreads-0-minimal[uthreads-0-minimal].

== Week 3

=== Lecture 4: 2023-03-04; 1,5h

* The `uthreads` library (continuation).
** Adding control synchronization - `uthreads-1-join` version.
*** Thread join - synchronization with another thread termination.
*** Moving from the `running` into the `non-ready` state and the _joiners_ list in a thread descriptor.
*** Moving from the `non-ready` into the `ready` state and delegation of execution.
** Adding I/O with non-busy waiting - `uthreads-2-sockets` version.
*** Non-blocking I/O and the epoll APIs in the Linux OS.
*** Auxiliary data structures and algorithms.
* Lecture resources
** link:../native/uthreads-1-join[uthreads-1-join].
** link:../native/uthreads-2-sockets[uthreads-2-sockets].

=== Lecture 5: 2023-03-08; 3,0h

* Data synchronization via the use of locks.
** Characterization of the lock behavior - lock states and transitions.
** Memory visibility guarantees.
** Using locks for mutual exclusion on shared data access.
** Using classes and member visibility to ensure proper _locked_ access to shared data.
* link:./exercises/2-data-synchronization.adoc[Exercises on data synchronization].

== Week 4

=== Lecture 6: 2023-03-11; 1,5h

* Control synchronization and synchronizers.
* The _semaphore_ synchronizer and an example use-case.
* The _monitor_ synchronizer building block.
** Condition characterization
*** wait sets.
*** _await_ and _signal_ behavior.
*** Lock release and acquisition guarantees.
* Using monitors to implement a simple unary semaphore without timeouts or fairness.

=== Lecture 7: 2023-03-15, 3,0h

* Thread interruption and its relation to control synchronization.
* Cancellation per timeout and per interruption.
* Adding cancellation to the simple semaphore implementation.
** Ensuring liveliness properties with cancellation.
* Implementation of a unary semaphore with fairness.
** Adding a FIFO queue representing the awaiting acquire requests.
* Using specific signalling to avoid the use of `signalAll`.
* Introduction the the _kernel-style_ synchronizer design.
* Lecture resources:
** link:../jvm/src/main/kotlin/pt/isel/pc/sketches/leic51n/sync[sketched monitors].
